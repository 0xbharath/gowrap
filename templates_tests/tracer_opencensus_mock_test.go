package templatestests

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_trace "go.opencensus.io/trace"
)

// TracerOpenCensusMock implements trace.Tracer
type TracerOpenCensusMock struct {
	t minimock.Tester

	funcFromContext          func(ctx context.Context) (sp1 *mm_trace.Span)
	inspectFuncFromContext   func(ctx context.Context)
	afterFromContextCounter  uint64
	beforeFromContextCounter uint64
	FromContextMock          mTracerOpenCensusMockFromContext

	funcNewContext          func(ctx context.Context, s *mm_trace.Span) (c1 context.Context)
	inspectFuncNewContext   func(ctx context.Context, s *mm_trace.Span)
	afterNewContextCounter  uint64
	beforeNewContextCounter uint64
	NewContextMock          mTracerOpenCensusMockNewContext

	funcStartSpan          func(ctx context.Context, name string, o ...mm_trace.StartOption) (c2 context.Context, sp1 *mm_trace.Span)
	inspectFuncStartSpan   func(ctx context.Context, name string, o ...mm_trace.StartOption)
	afterStartSpanCounter  uint64
	beforeStartSpanCounter uint64
	StartSpanMock          mTracerOpenCensusMockStartSpan

	funcStartSpanWithRemoteParent          func(ctx context.Context, name string, parent mm_trace.SpanContext, o ...mm_trace.StartOption) (c2 context.Context, sp1 *mm_trace.Span)
	inspectFuncStartSpanWithRemoteParent   func(ctx context.Context, name string, parent mm_trace.SpanContext, o ...mm_trace.StartOption)
	afterStartSpanWithRemoteParentCounter  uint64
	beforeStartSpanWithRemoteParentCounter uint64
	StartSpanWithRemoteParentMock          mTracerOpenCensusMockStartSpanWithRemoteParent
}

// NewTracerOpenCensusMock returns a mock for trace.Tracer
func NewTracerOpenCensusMock(t minimock.Tester) *TracerOpenCensusMock {
	m := &TracerOpenCensusMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.FromContextMock = mTracerOpenCensusMockFromContext{mock: m}
	m.FromContextMock.callArgs = []*TracerOpenCensusMockFromContextParams{}

	m.NewContextMock = mTracerOpenCensusMockNewContext{mock: m}
	m.NewContextMock.callArgs = []*TracerOpenCensusMockNewContextParams{}

	m.StartSpanMock = mTracerOpenCensusMockStartSpan{mock: m}
	m.StartSpanMock.callArgs = []*TracerOpenCensusMockStartSpanParams{}

	m.StartSpanWithRemoteParentMock = mTracerOpenCensusMockStartSpanWithRemoteParent{mock: m}
	m.StartSpanWithRemoteParentMock.callArgs = []*TracerOpenCensusMockStartSpanWithRemoteParentParams{}

	return m
}

type mTracerOpenCensusMockFromContext struct {
	mock               *TracerOpenCensusMock
	defaultExpectation *TracerOpenCensusMockFromContextExpectation
	expectations       []*TracerOpenCensusMockFromContextExpectation

	callArgs []*TracerOpenCensusMockFromContextParams
	mutex    sync.RWMutex
}

// TracerOpenCensusMockFromContextExpectation specifies expectation struct of the Tracer.FromContext
type TracerOpenCensusMockFromContextExpectation struct {
	mock    *TracerOpenCensusMock
	params  *TracerOpenCensusMockFromContextParams
	results *TracerOpenCensusMockFromContextResults
	Counter uint64
}

// TracerOpenCensusMockFromContextParams contains parameters of the Tracer.FromContext
type TracerOpenCensusMockFromContextParams struct {
	ctx context.Context
}

// TracerOpenCensusMockFromContextResults contains results of the Tracer.FromContext
type TracerOpenCensusMockFromContextResults struct {
	sp1 *mm_trace.Span
}

// Expect sets up expected params for Tracer.FromContext
func (mmFromContext *mTracerOpenCensusMockFromContext) Expect(ctx context.Context) *mTracerOpenCensusMockFromContext {
	if mmFromContext.mock.funcFromContext != nil {
		mmFromContext.mock.t.Fatalf("TracerOpenCensusMock.FromContext mock is already set by Set")
	}

	if mmFromContext.defaultExpectation == nil {
		mmFromContext.defaultExpectation = &TracerOpenCensusMockFromContextExpectation{}
	}

	mmFromContext.defaultExpectation.params = &TracerOpenCensusMockFromContextParams{ctx}
	for _, e := range mmFromContext.expectations {
		if minimock.Equal(e.params, mmFromContext.defaultExpectation.params) {
			mmFromContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFromContext.defaultExpectation.params)
		}
	}

	return mmFromContext
}

// Inspect accepts an inspector function that has same arguments as the Tracer.FromContext
func (mmFromContext *mTracerOpenCensusMockFromContext) Inspect(f func(ctx context.Context)) *mTracerOpenCensusMockFromContext {
	if mmFromContext.mock.inspectFuncFromContext != nil {
		mmFromContext.mock.t.Fatalf("Inspect function is already set for TracerOpenCensusMock.FromContext")
	}

	mmFromContext.mock.inspectFuncFromContext = f

	return mmFromContext
}

// Return sets up results that will be returned by Tracer.FromContext
func (mmFromContext *mTracerOpenCensusMockFromContext) Return(sp1 *mm_trace.Span) *TracerOpenCensusMock {
	if mmFromContext.mock.funcFromContext != nil {
		mmFromContext.mock.t.Fatalf("TracerOpenCensusMock.FromContext mock is already set by Set")
	}

	if mmFromContext.defaultExpectation == nil {
		mmFromContext.defaultExpectation = &TracerOpenCensusMockFromContextExpectation{mock: mmFromContext.mock}
	}
	mmFromContext.defaultExpectation.results = &TracerOpenCensusMockFromContextResults{sp1}
	return mmFromContext.mock
}

//Set uses given function f to mock the Tracer.FromContext method
func (mmFromContext *mTracerOpenCensusMockFromContext) Set(f func(ctx context.Context) (sp1 *mm_trace.Span)) *TracerOpenCensusMock {
	if mmFromContext.defaultExpectation != nil {
		mmFromContext.mock.t.Fatalf("Default expectation is already set for the Tracer.FromContext method")
	}

	if len(mmFromContext.expectations) > 0 {
		mmFromContext.mock.t.Fatalf("Some expectations are already set for the Tracer.FromContext method")
	}

	mmFromContext.mock.funcFromContext = f
	return mmFromContext.mock
}

// When sets expectation for the Tracer.FromContext which will trigger the result defined by the following
// Then helper
func (mmFromContext *mTracerOpenCensusMockFromContext) When(ctx context.Context) *TracerOpenCensusMockFromContextExpectation {
	if mmFromContext.mock.funcFromContext != nil {
		mmFromContext.mock.t.Fatalf("TracerOpenCensusMock.FromContext mock is already set by Set")
	}

	expectation := &TracerOpenCensusMockFromContextExpectation{
		mock:   mmFromContext.mock,
		params: &TracerOpenCensusMockFromContextParams{ctx},
	}
	mmFromContext.expectations = append(mmFromContext.expectations, expectation)
	return expectation
}

// Then sets up Tracer.FromContext return parameters for the expectation previously defined by the When method
func (e *TracerOpenCensusMockFromContextExpectation) Then(sp1 *mm_trace.Span) *TracerOpenCensusMock {
	e.results = &TracerOpenCensusMockFromContextResults{sp1}
	return e.mock
}

// FromContext implements trace.Tracer
func (mmFromContext *TracerOpenCensusMock) FromContext(ctx context.Context) (sp1 *mm_trace.Span) {
	mm_atomic.AddUint64(&mmFromContext.beforeFromContextCounter, 1)
	defer mm_atomic.AddUint64(&mmFromContext.afterFromContextCounter, 1)

	if mmFromContext.inspectFuncFromContext != nil {
		mmFromContext.inspectFuncFromContext(ctx)
	}

	mm_params := &TracerOpenCensusMockFromContextParams{ctx}

	// Record call args
	mmFromContext.FromContextMock.mutex.Lock()
	mmFromContext.FromContextMock.callArgs = append(mmFromContext.FromContextMock.callArgs, mm_params)
	mmFromContext.FromContextMock.mutex.Unlock()

	for _, e := range mmFromContext.FromContextMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1
		}
	}

	if mmFromContext.FromContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFromContext.FromContextMock.defaultExpectation.Counter, 1)
		mm_want := mmFromContext.FromContextMock.defaultExpectation.params
		mm_got := TracerOpenCensusMockFromContextParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFromContext.t.Errorf("TracerOpenCensusMock.FromContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFromContext.FromContextMock.defaultExpectation.results
		if mm_results == nil {
			mmFromContext.t.Fatal("No results are set for the TracerOpenCensusMock.FromContext")
		}
		return (*mm_results).sp1
	}
	if mmFromContext.funcFromContext != nil {
		return mmFromContext.funcFromContext(ctx)
	}
	mmFromContext.t.Fatalf("Unexpected call to TracerOpenCensusMock.FromContext. %v", ctx)
	return
}

// FromContextAfterCounter returns a count of finished TracerOpenCensusMock.FromContext invocations
func (mmFromContext *TracerOpenCensusMock) FromContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFromContext.afterFromContextCounter)
}

// FromContextBeforeCounter returns a count of TracerOpenCensusMock.FromContext invocations
func (mmFromContext *TracerOpenCensusMock) FromContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFromContext.beforeFromContextCounter)
}

// Calls returns a list of arguments used in each call to TracerOpenCensusMock.FromContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFromContext *mTracerOpenCensusMockFromContext) Calls() []*TracerOpenCensusMockFromContextParams {
	mmFromContext.mutex.RLock()

	argCopy := make([]*TracerOpenCensusMockFromContextParams, len(mmFromContext.callArgs))
	copy(argCopy, mmFromContext.callArgs)

	mmFromContext.mutex.RUnlock()

	return argCopy
}

// MinimockFromContextDone returns true if the count of the FromContext invocations corresponds
// the number of defined expectations
func (m *TracerOpenCensusMock) MinimockFromContextDone() bool {
	for _, e := range m.FromContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FromContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFromContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFromContext != nil && mm_atomic.LoadUint64(&m.afterFromContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockFromContextInspect logs each unmet expectation
func (m *TracerOpenCensusMock) MinimockFromContextInspect() {
	for _, e := range m.FromContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TracerOpenCensusMock.FromContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FromContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFromContextCounter) < 1 {
		if m.FromContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TracerOpenCensusMock.FromContext")
		} else {
			m.t.Errorf("Expected call to TracerOpenCensusMock.FromContext with params: %#v", *m.FromContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFromContext != nil && mm_atomic.LoadUint64(&m.afterFromContextCounter) < 1 {
		m.t.Error("Expected call to TracerOpenCensusMock.FromContext")
	}
}

type mTracerOpenCensusMockNewContext struct {
	mock               *TracerOpenCensusMock
	defaultExpectation *TracerOpenCensusMockNewContextExpectation
	expectations       []*TracerOpenCensusMockNewContextExpectation

	callArgs []*TracerOpenCensusMockNewContextParams
	mutex    sync.RWMutex
}

// TracerOpenCensusMockNewContextExpectation specifies expectation struct of the Tracer.NewContext
type TracerOpenCensusMockNewContextExpectation struct {
	mock    *TracerOpenCensusMock
	params  *TracerOpenCensusMockNewContextParams
	results *TracerOpenCensusMockNewContextResults
	Counter uint64
}

// TracerOpenCensusMockNewContextParams contains parameters of the Tracer.NewContext
type TracerOpenCensusMockNewContextParams struct {
	ctx context.Context
	s   *mm_trace.Span
}

// TracerOpenCensusMockNewContextResults contains results of the Tracer.NewContext
type TracerOpenCensusMockNewContextResults struct {
	c1 context.Context
}

// Expect sets up expected params for Tracer.NewContext
func (mmNewContext *mTracerOpenCensusMockNewContext) Expect(ctx context.Context, s *mm_trace.Span) *mTracerOpenCensusMockNewContext {
	if mmNewContext.mock.funcNewContext != nil {
		mmNewContext.mock.t.Fatalf("TracerOpenCensusMock.NewContext mock is already set by Set")
	}

	if mmNewContext.defaultExpectation == nil {
		mmNewContext.defaultExpectation = &TracerOpenCensusMockNewContextExpectation{}
	}

	mmNewContext.defaultExpectation.params = &TracerOpenCensusMockNewContextParams{ctx, s}
	for _, e := range mmNewContext.expectations {
		if minimock.Equal(e.params, mmNewContext.defaultExpectation.params) {
			mmNewContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNewContext.defaultExpectation.params)
		}
	}

	return mmNewContext
}

// Inspect accepts an inspector function that has same arguments as the Tracer.NewContext
func (mmNewContext *mTracerOpenCensusMockNewContext) Inspect(f func(ctx context.Context, s *mm_trace.Span)) *mTracerOpenCensusMockNewContext {
	if mmNewContext.mock.inspectFuncNewContext != nil {
		mmNewContext.mock.t.Fatalf("Inspect function is already set for TracerOpenCensusMock.NewContext")
	}

	mmNewContext.mock.inspectFuncNewContext = f

	return mmNewContext
}

// Return sets up results that will be returned by Tracer.NewContext
func (mmNewContext *mTracerOpenCensusMockNewContext) Return(c1 context.Context) *TracerOpenCensusMock {
	if mmNewContext.mock.funcNewContext != nil {
		mmNewContext.mock.t.Fatalf("TracerOpenCensusMock.NewContext mock is already set by Set")
	}

	if mmNewContext.defaultExpectation == nil {
		mmNewContext.defaultExpectation = &TracerOpenCensusMockNewContextExpectation{mock: mmNewContext.mock}
	}
	mmNewContext.defaultExpectation.results = &TracerOpenCensusMockNewContextResults{c1}
	return mmNewContext.mock
}

//Set uses given function f to mock the Tracer.NewContext method
func (mmNewContext *mTracerOpenCensusMockNewContext) Set(f func(ctx context.Context, s *mm_trace.Span) (c1 context.Context)) *TracerOpenCensusMock {
	if mmNewContext.defaultExpectation != nil {
		mmNewContext.mock.t.Fatalf("Default expectation is already set for the Tracer.NewContext method")
	}

	if len(mmNewContext.expectations) > 0 {
		mmNewContext.mock.t.Fatalf("Some expectations are already set for the Tracer.NewContext method")
	}

	mmNewContext.mock.funcNewContext = f
	return mmNewContext.mock
}

// When sets expectation for the Tracer.NewContext which will trigger the result defined by the following
// Then helper
func (mmNewContext *mTracerOpenCensusMockNewContext) When(ctx context.Context, s *mm_trace.Span) *TracerOpenCensusMockNewContextExpectation {
	if mmNewContext.mock.funcNewContext != nil {
		mmNewContext.mock.t.Fatalf("TracerOpenCensusMock.NewContext mock is already set by Set")
	}

	expectation := &TracerOpenCensusMockNewContextExpectation{
		mock:   mmNewContext.mock,
		params: &TracerOpenCensusMockNewContextParams{ctx, s},
	}
	mmNewContext.expectations = append(mmNewContext.expectations, expectation)
	return expectation
}

// Then sets up Tracer.NewContext return parameters for the expectation previously defined by the When method
func (e *TracerOpenCensusMockNewContextExpectation) Then(c1 context.Context) *TracerOpenCensusMock {
	e.results = &TracerOpenCensusMockNewContextResults{c1}
	return e.mock
}

// NewContext implements trace.Tracer
func (mmNewContext *TracerOpenCensusMock) NewContext(ctx context.Context, s *mm_trace.Span) (c1 context.Context) {
	mm_atomic.AddUint64(&mmNewContext.beforeNewContextCounter, 1)
	defer mm_atomic.AddUint64(&mmNewContext.afterNewContextCounter, 1)

	if mmNewContext.inspectFuncNewContext != nil {
		mmNewContext.inspectFuncNewContext(ctx, s)
	}

	mm_params := &TracerOpenCensusMockNewContextParams{ctx, s}

	// Record call args
	mmNewContext.NewContextMock.mutex.Lock()
	mmNewContext.NewContextMock.callArgs = append(mmNewContext.NewContextMock.callArgs, mm_params)
	mmNewContext.NewContextMock.mutex.Unlock()

	for _, e := range mmNewContext.NewContextMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1
		}
	}

	if mmNewContext.NewContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewContext.NewContextMock.defaultExpectation.Counter, 1)
		mm_want := mmNewContext.NewContextMock.defaultExpectation.params
		mm_got := TracerOpenCensusMockNewContextParams{ctx, s}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNewContext.t.Errorf("TracerOpenCensusMock.NewContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNewContext.NewContextMock.defaultExpectation.results
		if mm_results == nil {
			mmNewContext.t.Fatal("No results are set for the TracerOpenCensusMock.NewContext")
		}
		return (*mm_results).c1
	}
	if mmNewContext.funcNewContext != nil {
		return mmNewContext.funcNewContext(ctx, s)
	}
	mmNewContext.t.Fatalf("Unexpected call to TracerOpenCensusMock.NewContext. %v %v", ctx, s)
	return
}

// NewContextAfterCounter returns a count of finished TracerOpenCensusMock.NewContext invocations
func (mmNewContext *TracerOpenCensusMock) NewContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewContext.afterNewContextCounter)
}

// NewContextBeforeCounter returns a count of TracerOpenCensusMock.NewContext invocations
func (mmNewContext *TracerOpenCensusMock) NewContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewContext.beforeNewContextCounter)
}

// Calls returns a list of arguments used in each call to TracerOpenCensusMock.NewContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNewContext *mTracerOpenCensusMockNewContext) Calls() []*TracerOpenCensusMockNewContextParams {
	mmNewContext.mutex.RLock()

	argCopy := make([]*TracerOpenCensusMockNewContextParams, len(mmNewContext.callArgs))
	copy(argCopy, mmNewContext.callArgs)

	mmNewContext.mutex.RUnlock()

	return argCopy
}

// MinimockNewContextDone returns true if the count of the NewContext invocations corresponds
// the number of defined expectations
func (m *TracerOpenCensusMock) MinimockNewContextDone() bool {
	for _, e := range m.NewContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewContext != nil && mm_atomic.LoadUint64(&m.afterNewContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewContextInspect logs each unmet expectation
func (m *TracerOpenCensusMock) MinimockNewContextInspect() {
	for _, e := range m.NewContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TracerOpenCensusMock.NewContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewContextCounter) < 1 {
		if m.NewContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TracerOpenCensusMock.NewContext")
		} else {
			m.t.Errorf("Expected call to TracerOpenCensusMock.NewContext with params: %#v", *m.NewContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewContext != nil && mm_atomic.LoadUint64(&m.afterNewContextCounter) < 1 {
		m.t.Error("Expected call to TracerOpenCensusMock.NewContext")
	}
}

type mTracerOpenCensusMockStartSpan struct {
	mock               *TracerOpenCensusMock
	defaultExpectation *TracerOpenCensusMockStartSpanExpectation
	expectations       []*TracerOpenCensusMockStartSpanExpectation

	callArgs []*TracerOpenCensusMockStartSpanParams
	mutex    sync.RWMutex
}

// TracerOpenCensusMockStartSpanExpectation specifies expectation struct of the Tracer.StartSpan
type TracerOpenCensusMockStartSpanExpectation struct {
	mock    *TracerOpenCensusMock
	params  *TracerOpenCensusMockStartSpanParams
	results *TracerOpenCensusMockStartSpanResults
	Counter uint64
}

// TracerOpenCensusMockStartSpanParams contains parameters of the Tracer.StartSpan
type TracerOpenCensusMockStartSpanParams struct {
	ctx  context.Context
	name string
	o    []mm_trace.StartOption
}

// TracerOpenCensusMockStartSpanResults contains results of the Tracer.StartSpan
type TracerOpenCensusMockStartSpanResults struct {
	c2  context.Context
	sp1 *mm_trace.Span
}

// Expect sets up expected params for Tracer.StartSpan
func (mmStartSpan *mTracerOpenCensusMockStartSpan) Expect(ctx context.Context, name string, o ...mm_trace.StartOption) *mTracerOpenCensusMockStartSpan {
	if mmStartSpan.mock.funcStartSpan != nil {
		mmStartSpan.mock.t.Fatalf("TracerOpenCensusMock.StartSpan mock is already set by Set")
	}

	if mmStartSpan.defaultExpectation == nil {
		mmStartSpan.defaultExpectation = &TracerOpenCensusMockStartSpanExpectation{}
	}

	mmStartSpan.defaultExpectation.params = &TracerOpenCensusMockStartSpanParams{ctx, name, o}
	for _, e := range mmStartSpan.expectations {
		if minimock.Equal(e.params, mmStartSpan.defaultExpectation.params) {
			mmStartSpan.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStartSpan.defaultExpectation.params)
		}
	}

	return mmStartSpan
}

// Inspect accepts an inspector function that has same arguments as the Tracer.StartSpan
func (mmStartSpan *mTracerOpenCensusMockStartSpan) Inspect(f func(ctx context.Context, name string, o ...mm_trace.StartOption)) *mTracerOpenCensusMockStartSpan {
	if mmStartSpan.mock.inspectFuncStartSpan != nil {
		mmStartSpan.mock.t.Fatalf("Inspect function is already set for TracerOpenCensusMock.StartSpan")
	}

	mmStartSpan.mock.inspectFuncStartSpan = f

	return mmStartSpan
}

// Return sets up results that will be returned by Tracer.StartSpan
func (mmStartSpan *mTracerOpenCensusMockStartSpan) Return(c2 context.Context, sp1 *mm_trace.Span) *TracerOpenCensusMock {
	if mmStartSpan.mock.funcStartSpan != nil {
		mmStartSpan.mock.t.Fatalf("TracerOpenCensusMock.StartSpan mock is already set by Set")
	}

	if mmStartSpan.defaultExpectation == nil {
		mmStartSpan.defaultExpectation = &TracerOpenCensusMockStartSpanExpectation{mock: mmStartSpan.mock}
	}
	mmStartSpan.defaultExpectation.results = &TracerOpenCensusMockStartSpanResults{c2, sp1}
	return mmStartSpan.mock
}

//Set uses given function f to mock the Tracer.StartSpan method
func (mmStartSpan *mTracerOpenCensusMockStartSpan) Set(f func(ctx context.Context, name string, o ...mm_trace.StartOption) (c2 context.Context, sp1 *mm_trace.Span)) *TracerOpenCensusMock {
	if mmStartSpan.defaultExpectation != nil {
		mmStartSpan.mock.t.Fatalf("Default expectation is already set for the Tracer.StartSpan method")
	}

	if len(mmStartSpan.expectations) > 0 {
		mmStartSpan.mock.t.Fatalf("Some expectations are already set for the Tracer.StartSpan method")
	}

	mmStartSpan.mock.funcStartSpan = f
	return mmStartSpan.mock
}

// When sets expectation for the Tracer.StartSpan which will trigger the result defined by the following
// Then helper
func (mmStartSpan *mTracerOpenCensusMockStartSpan) When(ctx context.Context, name string, o ...mm_trace.StartOption) *TracerOpenCensusMockStartSpanExpectation {
	if mmStartSpan.mock.funcStartSpan != nil {
		mmStartSpan.mock.t.Fatalf("TracerOpenCensusMock.StartSpan mock is already set by Set")
	}

	expectation := &TracerOpenCensusMockStartSpanExpectation{
		mock:   mmStartSpan.mock,
		params: &TracerOpenCensusMockStartSpanParams{ctx, name, o},
	}
	mmStartSpan.expectations = append(mmStartSpan.expectations, expectation)
	return expectation
}

// Then sets up Tracer.StartSpan return parameters for the expectation previously defined by the When method
func (e *TracerOpenCensusMockStartSpanExpectation) Then(c2 context.Context, sp1 *mm_trace.Span) *TracerOpenCensusMock {
	e.results = &TracerOpenCensusMockStartSpanResults{c2, sp1}
	return e.mock
}

// StartSpan implements trace.Tracer
func (mmStartSpan *TracerOpenCensusMock) StartSpan(ctx context.Context, name string, o ...mm_trace.StartOption) (c2 context.Context, sp1 *mm_trace.Span) {
	mm_atomic.AddUint64(&mmStartSpan.beforeStartSpanCounter, 1)
	defer mm_atomic.AddUint64(&mmStartSpan.afterStartSpanCounter, 1)

	if mmStartSpan.inspectFuncStartSpan != nil {
		mmStartSpan.inspectFuncStartSpan(ctx, name, o...)
	}

	mm_params := &TracerOpenCensusMockStartSpanParams{ctx, name, o}

	// Record call args
	mmStartSpan.StartSpanMock.mutex.Lock()
	mmStartSpan.StartSpanMock.callArgs = append(mmStartSpan.StartSpanMock.callArgs, mm_params)
	mmStartSpan.StartSpanMock.mutex.Unlock()

	for _, e := range mmStartSpan.StartSpanMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.sp1
		}
	}

	if mmStartSpan.StartSpanMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStartSpan.StartSpanMock.defaultExpectation.Counter, 1)
		mm_want := mmStartSpan.StartSpanMock.defaultExpectation.params
		mm_got := TracerOpenCensusMockStartSpanParams{ctx, name, o}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStartSpan.t.Errorf("TracerOpenCensusMock.StartSpan got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStartSpan.StartSpanMock.defaultExpectation.results
		if mm_results == nil {
			mmStartSpan.t.Fatal("No results are set for the TracerOpenCensusMock.StartSpan")
		}
		return (*mm_results).c2, (*mm_results).sp1
	}
	if mmStartSpan.funcStartSpan != nil {
		return mmStartSpan.funcStartSpan(ctx, name, o...)
	}
	mmStartSpan.t.Fatalf("Unexpected call to TracerOpenCensusMock.StartSpan. %v %v %v", ctx, name, o)
	return
}

// StartSpanAfterCounter returns a count of finished TracerOpenCensusMock.StartSpan invocations
func (mmStartSpan *TracerOpenCensusMock) StartSpanAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartSpan.afterStartSpanCounter)
}

// StartSpanBeforeCounter returns a count of TracerOpenCensusMock.StartSpan invocations
func (mmStartSpan *TracerOpenCensusMock) StartSpanBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartSpan.beforeStartSpanCounter)
}

// Calls returns a list of arguments used in each call to TracerOpenCensusMock.StartSpan.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStartSpan *mTracerOpenCensusMockStartSpan) Calls() []*TracerOpenCensusMockStartSpanParams {
	mmStartSpan.mutex.RLock()

	argCopy := make([]*TracerOpenCensusMockStartSpanParams, len(mmStartSpan.callArgs))
	copy(argCopy, mmStartSpan.callArgs)

	mmStartSpan.mutex.RUnlock()

	return argCopy
}

// MinimockStartSpanDone returns true if the count of the StartSpan invocations corresponds
// the number of defined expectations
func (m *TracerOpenCensusMock) MinimockStartSpanDone() bool {
	for _, e := range m.StartSpanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartSpanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartSpanCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStartSpan != nil && mm_atomic.LoadUint64(&m.afterStartSpanCounter) < 1 {
		return false
	}
	return true
}

// MinimockStartSpanInspect logs each unmet expectation
func (m *TracerOpenCensusMock) MinimockStartSpanInspect() {
	for _, e := range m.StartSpanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TracerOpenCensusMock.StartSpan with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartSpanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartSpanCounter) < 1 {
		if m.StartSpanMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TracerOpenCensusMock.StartSpan")
		} else {
			m.t.Errorf("Expected call to TracerOpenCensusMock.StartSpan with params: %#v", *m.StartSpanMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStartSpan != nil && mm_atomic.LoadUint64(&m.afterStartSpanCounter) < 1 {
		m.t.Error("Expected call to TracerOpenCensusMock.StartSpan")
	}
}

type mTracerOpenCensusMockStartSpanWithRemoteParent struct {
	mock               *TracerOpenCensusMock
	defaultExpectation *TracerOpenCensusMockStartSpanWithRemoteParentExpectation
	expectations       []*TracerOpenCensusMockStartSpanWithRemoteParentExpectation

	callArgs []*TracerOpenCensusMockStartSpanWithRemoteParentParams
	mutex    sync.RWMutex
}

// TracerOpenCensusMockStartSpanWithRemoteParentExpectation specifies expectation struct of the Tracer.StartSpanWithRemoteParent
type TracerOpenCensusMockStartSpanWithRemoteParentExpectation struct {
	mock    *TracerOpenCensusMock
	params  *TracerOpenCensusMockStartSpanWithRemoteParentParams
	results *TracerOpenCensusMockStartSpanWithRemoteParentResults
	Counter uint64
}

// TracerOpenCensusMockStartSpanWithRemoteParentParams contains parameters of the Tracer.StartSpanWithRemoteParent
type TracerOpenCensusMockStartSpanWithRemoteParentParams struct {
	ctx    context.Context
	name   string
	parent mm_trace.SpanContext
	o      []mm_trace.StartOption
}

// TracerOpenCensusMockStartSpanWithRemoteParentResults contains results of the Tracer.StartSpanWithRemoteParent
type TracerOpenCensusMockStartSpanWithRemoteParentResults struct {
	c2  context.Context
	sp1 *mm_trace.Span
}

// Expect sets up expected params for Tracer.StartSpanWithRemoteParent
func (mmStartSpanWithRemoteParent *mTracerOpenCensusMockStartSpanWithRemoteParent) Expect(ctx context.Context, name string, parent mm_trace.SpanContext, o ...mm_trace.StartOption) *mTracerOpenCensusMockStartSpanWithRemoteParent {
	if mmStartSpanWithRemoteParent.mock.funcStartSpanWithRemoteParent != nil {
		mmStartSpanWithRemoteParent.mock.t.Fatalf("TracerOpenCensusMock.StartSpanWithRemoteParent mock is already set by Set")
	}

	if mmStartSpanWithRemoteParent.defaultExpectation == nil {
		mmStartSpanWithRemoteParent.defaultExpectation = &TracerOpenCensusMockStartSpanWithRemoteParentExpectation{}
	}

	mmStartSpanWithRemoteParent.defaultExpectation.params = &TracerOpenCensusMockStartSpanWithRemoteParentParams{ctx, name, parent, o}
	for _, e := range mmStartSpanWithRemoteParent.expectations {
		if minimock.Equal(e.params, mmStartSpanWithRemoteParent.defaultExpectation.params) {
			mmStartSpanWithRemoteParent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStartSpanWithRemoteParent.defaultExpectation.params)
		}
	}

	return mmStartSpanWithRemoteParent
}

// Inspect accepts an inspector function that has same arguments as the Tracer.StartSpanWithRemoteParent
func (mmStartSpanWithRemoteParent *mTracerOpenCensusMockStartSpanWithRemoteParent) Inspect(f func(ctx context.Context, name string, parent mm_trace.SpanContext, o ...mm_trace.StartOption)) *mTracerOpenCensusMockStartSpanWithRemoteParent {
	if mmStartSpanWithRemoteParent.mock.inspectFuncStartSpanWithRemoteParent != nil {
		mmStartSpanWithRemoteParent.mock.t.Fatalf("Inspect function is already set for TracerOpenCensusMock.StartSpanWithRemoteParent")
	}

	mmStartSpanWithRemoteParent.mock.inspectFuncStartSpanWithRemoteParent = f

	return mmStartSpanWithRemoteParent
}

// Return sets up results that will be returned by Tracer.StartSpanWithRemoteParent
func (mmStartSpanWithRemoteParent *mTracerOpenCensusMockStartSpanWithRemoteParent) Return(c2 context.Context, sp1 *mm_trace.Span) *TracerOpenCensusMock {
	if mmStartSpanWithRemoteParent.mock.funcStartSpanWithRemoteParent != nil {
		mmStartSpanWithRemoteParent.mock.t.Fatalf("TracerOpenCensusMock.StartSpanWithRemoteParent mock is already set by Set")
	}

	if mmStartSpanWithRemoteParent.defaultExpectation == nil {
		mmStartSpanWithRemoteParent.defaultExpectation = &TracerOpenCensusMockStartSpanWithRemoteParentExpectation{mock: mmStartSpanWithRemoteParent.mock}
	}
	mmStartSpanWithRemoteParent.defaultExpectation.results = &TracerOpenCensusMockStartSpanWithRemoteParentResults{c2, sp1}
	return mmStartSpanWithRemoteParent.mock
}

//Set uses given function f to mock the Tracer.StartSpanWithRemoteParent method
func (mmStartSpanWithRemoteParent *mTracerOpenCensusMockStartSpanWithRemoteParent) Set(f func(ctx context.Context, name string, parent mm_trace.SpanContext, o ...mm_trace.StartOption) (c2 context.Context, sp1 *mm_trace.Span)) *TracerOpenCensusMock {
	if mmStartSpanWithRemoteParent.defaultExpectation != nil {
		mmStartSpanWithRemoteParent.mock.t.Fatalf("Default expectation is already set for the Tracer.StartSpanWithRemoteParent method")
	}

	if len(mmStartSpanWithRemoteParent.expectations) > 0 {
		mmStartSpanWithRemoteParent.mock.t.Fatalf("Some expectations are already set for the Tracer.StartSpanWithRemoteParent method")
	}

	mmStartSpanWithRemoteParent.mock.funcStartSpanWithRemoteParent = f
	return mmStartSpanWithRemoteParent.mock
}

// When sets expectation for the Tracer.StartSpanWithRemoteParent which will trigger the result defined by the following
// Then helper
func (mmStartSpanWithRemoteParent *mTracerOpenCensusMockStartSpanWithRemoteParent) When(ctx context.Context, name string, parent mm_trace.SpanContext, o ...mm_trace.StartOption) *TracerOpenCensusMockStartSpanWithRemoteParentExpectation {
	if mmStartSpanWithRemoteParent.mock.funcStartSpanWithRemoteParent != nil {
		mmStartSpanWithRemoteParent.mock.t.Fatalf("TracerOpenCensusMock.StartSpanWithRemoteParent mock is already set by Set")
	}

	expectation := &TracerOpenCensusMockStartSpanWithRemoteParentExpectation{
		mock:   mmStartSpanWithRemoteParent.mock,
		params: &TracerOpenCensusMockStartSpanWithRemoteParentParams{ctx, name, parent, o},
	}
	mmStartSpanWithRemoteParent.expectations = append(mmStartSpanWithRemoteParent.expectations, expectation)
	return expectation
}

// Then sets up Tracer.StartSpanWithRemoteParent return parameters for the expectation previously defined by the When method
func (e *TracerOpenCensusMockStartSpanWithRemoteParentExpectation) Then(c2 context.Context, sp1 *mm_trace.Span) *TracerOpenCensusMock {
	e.results = &TracerOpenCensusMockStartSpanWithRemoteParentResults{c2, sp1}
	return e.mock
}

// StartSpanWithRemoteParent implements trace.Tracer
func (mmStartSpanWithRemoteParent *TracerOpenCensusMock) StartSpanWithRemoteParent(ctx context.Context, name string, parent mm_trace.SpanContext, o ...mm_trace.StartOption) (c2 context.Context, sp1 *mm_trace.Span) {
	mm_atomic.AddUint64(&mmStartSpanWithRemoteParent.beforeStartSpanWithRemoteParentCounter, 1)
	defer mm_atomic.AddUint64(&mmStartSpanWithRemoteParent.afterStartSpanWithRemoteParentCounter, 1)

	if mmStartSpanWithRemoteParent.inspectFuncStartSpanWithRemoteParent != nil {
		mmStartSpanWithRemoteParent.inspectFuncStartSpanWithRemoteParent(ctx, name, parent, o...)
	}

	mm_params := &TracerOpenCensusMockStartSpanWithRemoteParentParams{ctx, name, parent, o}

	// Record call args
	mmStartSpanWithRemoteParent.StartSpanWithRemoteParentMock.mutex.Lock()
	mmStartSpanWithRemoteParent.StartSpanWithRemoteParentMock.callArgs = append(mmStartSpanWithRemoteParent.StartSpanWithRemoteParentMock.callArgs, mm_params)
	mmStartSpanWithRemoteParent.StartSpanWithRemoteParentMock.mutex.Unlock()

	for _, e := range mmStartSpanWithRemoteParent.StartSpanWithRemoteParentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.sp1
		}
	}

	if mmStartSpanWithRemoteParent.StartSpanWithRemoteParentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStartSpanWithRemoteParent.StartSpanWithRemoteParentMock.defaultExpectation.Counter, 1)
		mm_want := mmStartSpanWithRemoteParent.StartSpanWithRemoteParentMock.defaultExpectation.params
		mm_got := TracerOpenCensusMockStartSpanWithRemoteParentParams{ctx, name, parent, o}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStartSpanWithRemoteParent.t.Errorf("TracerOpenCensusMock.StartSpanWithRemoteParent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStartSpanWithRemoteParent.StartSpanWithRemoteParentMock.defaultExpectation.results
		if mm_results == nil {
			mmStartSpanWithRemoteParent.t.Fatal("No results are set for the TracerOpenCensusMock.StartSpanWithRemoteParent")
		}
		return (*mm_results).c2, (*mm_results).sp1
	}
	if mmStartSpanWithRemoteParent.funcStartSpanWithRemoteParent != nil {
		return mmStartSpanWithRemoteParent.funcStartSpanWithRemoteParent(ctx, name, parent, o...)
	}
	mmStartSpanWithRemoteParent.t.Fatalf("Unexpected call to TracerOpenCensusMock.StartSpanWithRemoteParent. %v %v %v %v", ctx, name, parent, o)
	return
}

// StartSpanWithRemoteParentAfterCounter returns a count of finished TracerOpenCensusMock.StartSpanWithRemoteParent invocations
func (mmStartSpanWithRemoteParent *TracerOpenCensusMock) StartSpanWithRemoteParentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartSpanWithRemoteParent.afterStartSpanWithRemoteParentCounter)
}

// StartSpanWithRemoteParentBeforeCounter returns a count of TracerOpenCensusMock.StartSpanWithRemoteParent invocations
func (mmStartSpanWithRemoteParent *TracerOpenCensusMock) StartSpanWithRemoteParentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartSpanWithRemoteParent.beforeStartSpanWithRemoteParentCounter)
}

// Calls returns a list of arguments used in each call to TracerOpenCensusMock.StartSpanWithRemoteParent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStartSpanWithRemoteParent *mTracerOpenCensusMockStartSpanWithRemoteParent) Calls() []*TracerOpenCensusMockStartSpanWithRemoteParentParams {
	mmStartSpanWithRemoteParent.mutex.RLock()

	argCopy := make([]*TracerOpenCensusMockStartSpanWithRemoteParentParams, len(mmStartSpanWithRemoteParent.callArgs))
	copy(argCopy, mmStartSpanWithRemoteParent.callArgs)

	mmStartSpanWithRemoteParent.mutex.RUnlock()

	return argCopy
}

// MinimockStartSpanWithRemoteParentDone returns true if the count of the StartSpanWithRemoteParent invocations corresponds
// the number of defined expectations
func (m *TracerOpenCensusMock) MinimockStartSpanWithRemoteParentDone() bool {
	for _, e := range m.StartSpanWithRemoteParentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartSpanWithRemoteParentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartSpanWithRemoteParentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStartSpanWithRemoteParent != nil && mm_atomic.LoadUint64(&m.afterStartSpanWithRemoteParentCounter) < 1 {
		return false
	}
	return true
}

// MinimockStartSpanWithRemoteParentInspect logs each unmet expectation
func (m *TracerOpenCensusMock) MinimockStartSpanWithRemoteParentInspect() {
	for _, e := range m.StartSpanWithRemoteParentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TracerOpenCensusMock.StartSpanWithRemoteParent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartSpanWithRemoteParentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartSpanWithRemoteParentCounter) < 1 {
		if m.StartSpanWithRemoteParentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TracerOpenCensusMock.StartSpanWithRemoteParent")
		} else {
			m.t.Errorf("Expected call to TracerOpenCensusMock.StartSpanWithRemoteParent with params: %#v", *m.StartSpanWithRemoteParentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStartSpanWithRemoteParent != nil && mm_atomic.LoadUint64(&m.afterStartSpanWithRemoteParentCounter) < 1 {
		m.t.Error("Expected call to TracerOpenCensusMock.StartSpanWithRemoteParent")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TracerOpenCensusMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockFromContextInspect()

		m.MinimockNewContextInspect()

		m.MinimockStartSpanInspect()

		m.MinimockStartSpanWithRemoteParentInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TracerOpenCensusMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TracerOpenCensusMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockFromContextDone() &&
		m.MinimockNewContextDone() &&
		m.MinimockStartSpanDone() &&
		m.MinimockStartSpanWithRemoteParentDone()
}
